from tensor import Tensor,autograd_function
import tensor
program.options_from_args()

@autograd_function
def test_mul():
    print_ln('test_mul')
    i, j = 3, 3
    x = MultiArray([i, j], sfix)
    x.assign_all(2)
    x.print_reveal_nested()
    y = MultiArray([i, j], sfix)
    y.assign_all(5)
    y.print_reveal_nested()
    input1 = Tensor(x)
    input2 = Tensor(y)

    input3 = input1 *input2

    tensor.train()
    tensor.reset_op_id()

    input3 = input1 *input2
    input3.value.print_reveal_nested()
    input3.backward()
    input1.grad.print_reveal_nested()
    input2.grad.print_reveal_nested()

@autograd_function
def test_add():
    print_ln('test_add')
    i, j = 3, 3
    x = MultiArray([i, j], sfix)
    x.assign_all(2)
    x.print_reveal_nested()
    y = MultiArray([i, j], sfix)
    y.assign_all(5)
    y.print_reveal_nested()
    input1 = Tensor(x)
    input2 = Tensor(y)

    input3 = input1 +input2

    tensor.train()
    tensor.reset_op_id()

    input3 = input1 +input2
    input3.value.print_reveal_nested()
    input3.backward()
    input1.grad.print_reveal_nested()
    input2.grad.print_reveal_nested()

@autograd_function
def test_sub():
    print_ln('test_sub')
    i, j = 3, 3
    x = MultiArray([i, j], sfix)
    x.assign_all(2)
    x.print_reveal_nested()
    y = MultiArray([i, j], sfix)
    y.assign_all(5)
    y.print_reveal_nested()
    input1 = Tensor(x)
    input2 = Tensor(y)

    input3 = input1 -input2

    tensor.train()
    tensor.reset_op_id()

    input3 = input1 -input2
    input3.value.print_reveal_nested()
    input3.backward()
    input1.grad.print_reveal_nested()
    input2.grad.print_reveal_nested()

@autograd_function
def test_abs():
    i, j = 3, 3
    x = MultiArray([i, j], sfix)
    for i in range(0,3):
        for  j in range(0,3):
            x[i][j] = sfix(i-j)
    x.print_reveal_nested()
    input1 = Tensor(x)

    input2 = input1.abs()
    

    tensor.train()
    tensor.reset_op_id()

    input2 = input1.abs()
    input2.value.print_reveal_nested()
    input2.backward()
    
    input1.grad.print_reveal_nested()

@autograd_function
def test_exp():
    i, j = 3, 3
    x = MultiArray([i, j], sfix)
    for i in range(0,3):
        for  j in range(0,3):
            x[i][j] = sfix(i+j)
    x.print_reveal_nested()
    input1 = Tensor(x)

    input2 = input1.exp()

    tensor.train()
    tensor.reset_op_id()

    input2 = input1.exp()
    input2.backward()
    input2.value.print_reveal_nested()
    input1.grad.print_reveal_nested()

@autograd_function
def test_log():
    i, j = 3, 3
    x = MultiArray([i, j], sfix)
    for i in range(0,3):
        for  j in range(0,3):
            x[i][j] = sfix(i+j)
    x.print_reveal_nested()
    input1 = Tensor(x)

    input2 = input1.log()

    tensor.train()
    tensor.reset_op_id()

    input2 = input1.log()
    input2.backward()
    input2.value.print_reveal_nested()
    input1.grad.print_reveal_nested()

@autograd_function
def test_pow(pow):
    i, j = 3, 3
    x = MultiArray([i, j], sfix)
    for i in range(0,3):
        for  j in range(0,3):
            x[i][j] = sfix(i+j)
    x.print_reveal_nested()
    input1 = Tensor(x)

    input2 = input1.pow(pow)

    tensor.train()
    tensor.reset_op_id()

    input2 = input1.pow(pow)
    input2.backward()
    input2.value.print_reveal_nested()
    input1.grad.print_reveal_nested()

@autograd_function
def test_sum():
    i, j = 3, 3
    x = MultiArray([i, j], sfix)
    for i in range(0,3):
        for  j in range(0,3):
            x[i][j] = sfix(i+j)
    x.print_reveal_nested()
    input1 = Tensor(x)

    input2 = input1.sum()

    tensor.train()
    tensor.reset_op_id()

    input2 = input1.sum()
    input2.backward()
    input2.value.print_reveal_nested()
    input1.grad.print_reveal_nested()


@autograd_function
def test_var():
    i, j = 3, 3
    x = MultiArray([i, j], sfix)
    for i in range(0,3):
        for  j in range(0,3):
            x[i][j] = sfix(i+j)
    x.print_reveal_nested()
    input1 = Tensor(x)

    input2 = input1.var()

    tensor.train()
    tensor.reset_op_id()

    input2 = input1.var()
    input2.backward()
    input2.value.print_reveal_nested()
    input1.grad.print_reveal_nested()

@autograd_function
def test_std():
    i, j = 3, 3
    x = MultiArray([i, j], sfix)
    for i in range(0,3):
        for  j in range(0,3):
            x[i][j] = sfix(i+j)
    x.print_reveal_nested()
    input1 = Tensor(x)

    input2 = input1.std()

    tensor.train()
    tensor.reset_op_id()

    input2 = input1.std()
    input2.backward()
    input2.value.print_reveal_nested()
    input1.grad.print_reveal_nested()

@autograd_function
def test_addc():
    print_ln('test_addc')
    i, j = 3, 3
    x = MultiArray([i, j], sfix)
    for i in range(0,3):
        for  j in range(0,3):
            x[i][j] = sfix(i+j)
    x.print_reveal_nested()
    input1 = Tensor(x)

    input2 = input1 + 1

    tensor.train()
    tensor.reset_op_id()

    input2 = input1 + 1
    input2.backward()
    input2.value.print_reveal_nested()
    input1.grad.print_reveal_nested()

@autograd_function
def test_subc():
    print_ln('test_subc')
    i, j = 3, 3
    x = MultiArray([i, j], sfix)
    for i in range(0,3):
        for  j in range(0,3):
            x[i][j] = sfix(i+j)
    x.print_reveal_nested()
    input1 = Tensor(x)

    input2 = input1 - 1

    tensor.train()
    tensor.reset_op_id()

    input2 = input1 - 1
    input2.backward()
    input2.value.print_reveal_nested()
    input1.grad.print_reveal_nested()

@autograd_function
def test_mulc():
    print_ln('test_mulc')
    i, j = 3, 3
    x = MultiArray([i, j], sfix)
    for i in range(0,3):
        for  j in range(0,3):
            x[i][j] = sfix(i+j)
    x.print_reveal_nested()
    input1 = Tensor(x)

    input2 = input1 * 2

    tensor.train()
    tensor.reset_op_id()

    input2 = input1 * 2
    input2.backward()
    input2.value.print_reveal_nested()
    input1.grad.print_reveal_nested()

@autograd_function
def test_divc():
    print_ln('test_divc')
    i, j = 3, 3
    x = MultiArray([i, j], sfix)
    for i in range(0,3):
        for  j in range(0,3):
            x[i][j] = sfix(i+j)
    x.print_reveal_nested()
    input1 = Tensor(x)

    input2 = input1 / 2

    tensor.train()
    tensor.reset_op_id()

    input2 = input1 / 2
    input2.backward()
    input2.value.print_reveal_nested()
    input1.grad.print_reveal_nested()

@autograd_function
def test_neg():
    print_ln('test_neg')
    i, j = 3, 3
    x = MultiArray([i, j], sfix)
    for i in range(0,3):
        for  j in range(0,3):
            x[i][j] = sfix(i+j)
    x.print_reveal_nested()
    input1 = Tensor(x)

    input2 = -input1

    tensor.train()
    tensor.reset_op_id()

    input2 = -input1
    input2.backward()
    input2.value.print_reveal_nested()
    input1.grad.print_reveal_nested()

test_mul()
test_add()
test_sub()

#test_abs()
#test_exp()
#test_log()
#test_pow(3)
#test_sum()
#test_mean()
#test_var()
#test_std()

#test_addc()
#test_subc()
#test_mulc()
#test_divc()

#test_neg()